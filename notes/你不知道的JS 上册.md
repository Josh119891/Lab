## 编译原理
基础编译步骤:
1. 分词和词法分析 tokenizing / lexing
	**tokenizing** - 把字符组成的代码块拆分,分解成 词法单元 (token)
	
	```javascript
	const a = 2; // => tokens: [const, a, =, 2, ;]
	````
	
	**lexing** - 检查是否跟其他词法单元有关联，若有关联，则调用有关联的解析规则
	
2. 解析/词法分析
	将 token stream 转换成 抽象语法树 Abstract Syntax Tree, AST
	
3. 代码生成
	将AST转化为 可执行的代码
	
	
## 词法

	词法作用域根据源代码中声明变量的位置来确定该变量在何处可用。嵌套函数可访问声明于它们外部作用域的变量。


​	

## LHS和RHS

> 变量的赋值操作会执行两个动作， 首先编译器会在当前作用域中声明一个变量（如果之前没有声> 明过）， 然后在运行时引擎会在作用域中查找该变量， 如果能够找到就会对它赋值。

**LHS查询** 指的是找到变量的容器本身，从而可以对其进行赋值。也就是找到赋值操作的目标。LHS查询的时候会沿着作用域链进行查询，找到的话就会将值赋值给这个变量，如果到达作用域顶端仍然找不到，就会在作用域链顶端创建这个变量**(在严格模式中 LHS 查询失败时， 并不会创建并返回一个全局变量， 引擎会抛出同 RHS 查询失败时类似的 ReferenceError 异常)**

**RHS查询** 就是普通的查询变量的值，即获取变量的值。RHS查询的时候会沿着作用域链进行查询，找到的话就会取得这个值并返回。 **如果到达作用域顶端仍然找不到，引擎就会抛出 ReferenceError异常, 如果 RHS 查询找到了一个变量， 但是你尝试对这个变量的值进行不合理的操作，比如试图对一个非函数类型的值进行函数调用， 或着引用 null 或 undefined 类型的值中属性， 那么引擎会抛出另外一种类型的异常， 叫作 TypeError**

>如果查找的目的是对变量进行赋值， 那么就会使用 LHS 查询； 如果目的是获取变量的值， 就 >会使用 RHS 查询。赋值操作符会导致 LHS 查询。 ＝操作符或调用函数时传入参数的操作都会 >导致关联作用域的赋值操作



## CONST vs VAR vs LET

| const                                | var                                  | let                                                 |
| ------------------------------------ | ------------------------------------ | --------------------------------------------------- |
| 指针绑定，可以改变对象中的值，会提升 | 声明的变量只能是全局或者整个函数块的 | 声明的变量绑定在所在的作用域中，但不会得到 **提升** |

**变量和函数声明**都会提升， 函数优先. 而**函数表达式**不会提升





![const sample](/Users/josh/WorkStation/Lab/assets/const sample.png)

![var](/Users/josh/WorkStation/Lab/assets/var.png)

迭代时，每次把i++，然后把setTimeout送入任务队列中，等任务队列进行的时候，i 已经为6了



## 

